name: ğŸš€ KOBE Corporation CI/CD

# ==========================================
# DÃ‰CLENCHEMENT
# ==========================================
# Ce workflow se dÃ©clenche :
# - Automatiquement sur push vers main ou master
# - Automatiquement sur pull_request vers main ou master
# - Manuellement depuis l'onglet Actions (workflow_dispatch)
on:
  push:
    branches:
      - main
      - master
  pull_request:
    branches:
      - main
      - master
  workflow_dispatch:  # Permet de dÃ©clencher manuellement depuis GitHub

# ==========================================
# VARIABLES GLOBALES
# ==========================================
env:
  DOCKER_IMAGE: azerty78/kobecorporation-web
  DOCKERFILE_PATH: setup-front/Dockerfile
  DOCKER_CONTEXT: .

# ==========================================
# JOBS
# ==========================================
jobs:
  # ==========================================
  # JOB 1: Create Git Tags
  # ==========================================
  tags:
    name: ğŸ·ï¸ Create Git Tags
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      tag_created: ${{ steps.tag.outputs.created }}
      tag_name: ${{ steps.tag.outputs.name }}
      tag_type: ${{ steps.tag.outputs.type }}
      is_release: ${{ steps.tag.outputs.is_release }}
      semantic_version: ${{ steps.tag.outputs.semantic_version }}
    
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
      
      - name: âš™ï¸ Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
      
      - name: ğŸ“‹ Extract Version & Info
        id: version
        run: |
          echo "âœ… Informations sur les tags Git"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸ“Œ Ref: ${{ github.ref }}"
          echo "ğŸ”– SHA: ${{ github.sha }}"
          echo "ğŸŒ¿ Branch: ${{ github.ref_name }}"
          echo "ğŸ‘¤ Auteur: $(git log -1 --pretty=%an)"
          echo "ğŸ“… Date: $(git log -1 --pretty=%cd --date=format:%Y-%m-%d\ %H:%M:%S)"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          
          # Lire la version depuis package.json (mÃ©thode bash pure)
          if [ -f "package.json" ]; then
            # Extraire la version avec grep et sed (mÃ©thode simple et fiable)
            PACKAGE_VERSION=$(grep -m 1 '"version"' package.json | sed 's/.*"version"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/')
            if [ -z "$PACKAGE_VERSION" ]; then
              PACKAGE_VERSION="0.0.0"
            fi
            echo "ğŸ“¦ Version package.json: $PACKAGE_VERSION"
            echo "version=$PACKAGE_VERSION" >> $GITHUB_OUTPUT
          else
            echo "âš ï¸ package.json non trouvÃ©, utilisation de la version par dÃ©faut"
            echo "version=0.0.0" >> $GITHUB_OUTPUT
          fi
          
          # Afficher les 10 derniers tags
          echo ""
          echo "ğŸ“‹ Tags existants (10 derniers):"
          git tag -l --sort=-version:refname | head -10 || echo "  Aucun tag trouvÃ©"
          
          # Afficher les informations du commit
          echo ""
          echo "ğŸ“ Dernier commit:"
          echo "  SHA: $(git log -1 --pretty=%H)"
          COMMIT_MSG_FIRST_LINE=$(git log -1 --pretty=%B | head -n 1)
          echo "  Message: $COMMIT_MSG_FIRST_LINE"
          echo "  Auteur: $(git log -1 --pretty='%an <%ae>')"
      
      - name: ğŸ“Š Analyze Changes
        id: changes
        run: |
          echo "ğŸ“Š Analyse des changements:"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          
          # Compter les fichiers modifiÃ©s
          if [ "${{ github.event_name }}" == "pull_request" ]; then
            FILES_CHANGED=$(git diff --name-only ${{ github.event.pull_request.base.sha }} ${{ github.sha }} | wc -l)
            echo "ğŸ“ Fichiers modifiÃ©s: $FILES_CHANGED"
            
            # Afficher les types de changements
            echo ""
            echo "ğŸ“ Types de changements:"
            git diff --name-status ${{ github.event.pull_request.base.sha }} ${{ github.sha }} | \
              awk '{print "  " $1 " " $2}' | head -20 || echo "  Aucun changement dÃ©tectÃ©"
          else
            # Pour les pushes, comparer avec le commit prÃ©cÃ©dent
            PREV_SHA=$(git rev-parse HEAD~1 2>/dev/null || echo "")
            if [ -n "$PREV_SHA" ]; then
              FILES_CHANGED=$(git diff --name-only $PREV_SHA ${{ github.sha }} | wc -l)
              echo "ğŸ“ Fichiers modifiÃ©s: $FILES_CHANGED"
              
              echo ""
              echo "ğŸ“ Types de changements:"
              git diff --name-status $PREV_SHA ${{ github.sha }} | \
                awk '{print "  " $1 " " $2}' | head -20 || echo "  Aucun changement dÃ©tectÃ©"
            else
              echo "â„¹ï¸ Premier commit de la branche"
            fi
          fi
          
          # DÃ©tecter le type de changement (feat, fix, etc.)
          COMMIT_MSG=$(git log -1 --pretty=%B)
          if echo "$COMMIT_MSG" | grep -qiE "^(feat|feature)"; then
            CHANGE_TYPE="âœ¨ Feature"
          elif echo "$COMMIT_MSG" | grep -qiE "^(fix|bugfix)"; then
            CHANGE_TYPE="ğŸ› Fix"
          elif echo "$COMMIT_MSG" | grep -qiE "^(refactor)"; then
            CHANGE_TYPE="â™»ï¸ Refactor"
          elif echo "$COMMIT_MSG" | grep -qiE "^(docs|documentation)"; then
            CHANGE_TYPE="ğŸ“š Documentation"
          elif echo "$COMMIT_MSG" | grep -qiE "^(test)"; then
            CHANGE_TYPE="ğŸ§ª Test"
          elif echo "$COMMIT_MSG" | grep -qiE "^(chore)"; then
            CHANGE_TYPE="ğŸ”§ Chore"
          else
            CHANGE_TYPE="ğŸ“ Update"
          fi
          
          echo ""
          echo "ğŸ·ï¸ Type de changement dÃ©tectÃ©: $CHANGE_TYPE"
          echo "change_type=$CHANGE_TYPE" >> $GITHUB_OUTPUT
      
      - name: ğŸ·ï¸ Create Git Tag
        id: tag
        if: github.event_name != 'pull_request' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master')
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          SHA="${{ github.sha }}"
          BRANCH="${{ github.ref_name }}"
          COMMIT_MSG=$(git log -1 --pretty=%B)
          AUTHOR=$(git log -1 --pretty=%an)
          DATE=$(git log -1 --pretty=%cd --date=format:%Y-%m-%d\ %H:%M:%S)
          SHORT_SHA=$(echo $SHA | cut -c1-7)
          
          # DÃ©tecter le type de changement pour dÃ©terminer le type de tag
          CHANGE_TYPE="${{ steps.changes.outputs.change_type }}"
          
          # Si la version est 0.0.0, crÃ©er un tag de dÃ©veloppement
          # Sinon, crÃ©er un tag sÃ©mantique (v1.0.0, v1.1.0, etc.)
          if [ "$VERSION" = "0.0.0" ]; then
            # Tag de dÃ©veloppement avec SHA et timestamp
            TIMESTAMP=$(date +%Y%m%d%H%M%S)
            TAG_NAME="dev-${SHORT_SHA}-${TIMESTAMP}"
            TAG_TYPE="development"
            echo "ğŸ”§ CrÃ©ation d'un tag de dÃ©veloppement: $TAG_NAME"
          else
            # Tag sÃ©mantique basÃ© sur la version (v1.0.0, v1.1.0, etc.)
            TAG_NAME="v${VERSION}"
            TAG_TYPE="semantic"
            
            # VÃ©rifier si le tag sÃ©mantique existe dÃ©jÃ 
            if git rev-parse "$TAG_NAME" >/dev/null 2>&1; then
              echo "âš ï¸ Le tag sÃ©mantique $TAG_NAME existe dÃ©jÃ "
              echo "â„¹ï¸ Utilisation d'un tag de dÃ©veloppement Ã  la place"
              TIMESTAMP=$(date +%Y%m%d%H%M%S)
              TAG_NAME="dev-${SHORT_SHA}-${TIMESTAMP}"
              TAG_TYPE="development"
            else
              echo "ğŸ‰ CrÃ©ation d'un tag sÃ©mantique: $TAG_NAME"
            fi
          fi
          
          # CrÃ©er le message du tag enrichi (format simplifiÃ© pour Ã©viter les problÃ¨mes YAML)
          TAG_MESSAGE="Release $TAG_NAME - Version: $VERSION - Commit: $SHA - Branch: $BRANCH - Auteur: $AUTHOR - Date: $DATE - Type: $TAG_TYPE - Changement: $CHANGE_TYPE - Message: $COMMIT_MSG - GÃ©nÃ©rÃ© automatiquement par GitHub Actions"
          
          # CrÃ©er le tag annotÃ©
          git tag -a "$TAG_NAME" -m "$TAG_MESSAGE" "$SHA"
          
          echo "âœ… Tag crÃ©Ã©: $TAG_NAME"
          echo "name=$TAG_NAME" >> $GITHUB_OUTPUT
          echo "created=true" >> $GITHUB_OUTPUT
          echo "type=$TAG_TYPE" >> $GITHUB_OUTPUT
          
          # DÃ©tecter si c'est une release sÃ©mantique (version != 0.0.0 et tag sÃ©mantique)
          if [ "$VERSION" != "0.0.0" ] && [ "$TAG_TYPE" = "semantic" ]; then
            echo "is_release=true" >> $GITHUB_OUTPUT
            echo "semantic_version=$VERSION" >> $GITHUB_OUTPUT
            echo "ğŸ‰ Release sÃ©mantique dÃ©tectÃ©e (version: $VERSION)"
          else
            echo "is_release=false" >> $GITHUB_OUTPUT
            echo "semantic_version=" >> $GITHUB_OUTPUT
          fi
      
      - name: ğŸš€ Push Tags
        if: steps.tag.outputs.created == 'true'
        run: |
          TAG_NAME="${{ steps.tag.outputs.name }}"
          echo "ğŸš€ Push du tag $TAG_NAME vers le dÃ©pÃ´t..."
          git push origin "$TAG_NAME" || {
            echo "âš ï¸ Erreur lors du push du tag, peut-Ãªtre qu'il existe dÃ©jÃ  sur le serveur"
            exit 0  # Ne pas faire Ã©chouer le workflow si le tag existe dÃ©jÃ 
          }
          echo "âœ… Tag $TAG_NAME poussÃ© avec succÃ¨s"
      
      - name: ğŸ“‹ Summary
        run: |
          echo ""
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸ“‹ RÃ‰SUMÃ‰ DU JOB TAGS"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "âœ… Version: ${{ steps.version.outputs.version }}"
          if [ "${{ steps.tag.outputs.created }}" == "true" ]; then
            echo "âœ… Tag crÃ©Ã©: ${{ steps.tag.outputs.name }}"
            echo "ğŸ·ï¸  Type de tag: ${{ steps.tag.outputs.type }}"
            if [ "${{ steps.tag.outputs.is_release }}" == "true" ]; then
              echo "ğŸ‰ Release sÃ©mantique: ${{ steps.tag.outputs.semantic_version }}"
              echo "ğŸ“¦ L'image Docker sera taggÃ©e avec: ${{ steps.tag.outputs.tag_name }}"
              echo "ğŸš€ Une release GitHub sera crÃ©Ã©e automatiquement"
            else
              echo "ğŸ”§ Tag de dÃ©veloppement crÃ©Ã©"
            fi
          else
            echo "â„¹ï¸ Aucun tag crÃ©Ã© (PR ou branche non principale)"
          fi
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
  
  # ==========================================
  # JOB 2: Build Docker Image
  # ==========================================
  build:
    needs: tags
    name: ğŸ”¨ Build & Push Docker Image
    runs-on: ubuntu-latest
    
    steps:
      # Ã‰tape 1: Checkout du code
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4
      
      # Ã‰tape 2: Nettoyer et recrÃ©er les contextes Docker correctement
      - name: ğŸ§¹ Setup Docker Properly
        run: |
          # Supprimer buildx et contextes corrompus
          rm -rf ~/.docker/buildx 2>/dev/null || true
          rm -rf ~/.docker/contexts 2>/dev/null || true
          
          # RecrÃ©er la structure de contextes correctement
          mkdir -p ~/.docker/contexts/meta
          
          # CrÃ©er le rÃ©pertoire pour le contexte "." (hash de l'erreur)
          CONTEXT_DIR=~/.docker/contexts/meta/cdb4ee2aea69cc6a83331bbe96dc2caa9a299d21329efb0336fc02a82e1839a8
          mkdir -p "$CONTEXT_DIR"
          
          # CrÃ©er le fichier meta.json pour le contexte "."
          cat > "$CONTEXT_DIR/meta.json" <<'EOF'
          {
            "Name": ".",
            "Metadata": {
              "Description": "Default context"
            },
            "Endpoints": {
              "docker": {
                "Host": "unix:///var/run/docker.sock",
                "SkipTLSVerify": false
              }
            }
          }
          EOF
          
          # VÃ©rifier que le fichier a Ã©tÃ© crÃ©Ã©
          if [ -f "$CONTEXT_DIR/meta.json" ]; then
            echo "âœ… Contexte Docker '.' crÃ©Ã© avec succÃ¨s"
          else
            echo "âŒ Erreur: Impossible de crÃ©er le contexte"
            exit 1
          fi
      
      # Ã‰tape 3: Login Ã  DockerHub (TOUJOURS nÃ©cessaire pour pull les images de base)
      - name: ğŸ” Login to DockerHub
        run: |
          # Utiliser docker login directement (le contexte "." existe maintenant)
          echo "${{ secrets.DOCKERHUB_PASSWORD }}" | docker login -u "${{ secrets.DOCKERHUB_USERNAME }}" --password-stdin
          
          # VÃ©rifier le login en testant un pull d'image publique
          echo "âœ… Login DockerHub rÃ©ussi"
          
          # Test: essayer de pull node:22.13.1-alpine pour vÃ©rifier l'authentification
          echo "Test: Pull de node:22.13.1-alpine..."
          docker pull node:22.13.1-alpine || {
            echo "âŒ Erreur: Impossible de pull node:22.13.1-alpine"
            echo "VÃ©rification du config.json..."
            cat ~/.docker/config.json || echo "âš ï¸ Pas de config.json"
            exit 1
          }
          echo "âœ… Pull de node:22.13.1-alpine rÃ©ussi"
      
      # Ã‰tape 4: Extract metadata (tags, labels) avec intÃ©gration des tags Git
      - name: ğŸ“‹ Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.DOCKER_IMAGE }}
          tags: |
            # Tags Git (prioritaires si disponibles)
            type=raw,value=${{ needs.tags.outputs.tag_name }},enable=${{ needs.tags.outputs.tag_created }}
            # Tags sÃ©mantiques basÃ©s sur la version
            type=semver,pattern={{version}},enable=${{ needs.tags.outputs.is_release }}
            type=semver,pattern={{major}}.{{minor}},enable=${{ needs.tags.outputs.is_release }}
            # Tags de branche et SHA (fallback)
            type=ref,event=branch
            type=sha,prefix={{branch}}-
            # Tag latest uniquement sur la branche principale
            type=raw,value=latest,enable={{is_default_branch}}
            # Tags pour les PRs
            type=ref,event=pr
      
      # Ã‰tape 5: Lire les variables depuis le fichier .env
      - name: ğŸ“„ Load environment variables
        id: env
        run: |
          # Fonction pour extraire une variable d'un fichier .env
          extract_env_var() {
            local var_name=$1
            local file_path=$2
            if [ -f "$file_path" ]; then
              # Extraire la variable (ignorer les commentaires, gÃ©rer les espaces, guillemets, etc.)
              grep -E "^${var_name}=" "$file_path" | sed -E "s/^${var_name}=['\"]?([^'\"]*)['\"]?$/\1/" | head -1 | xargs || echo ""
            else
              echo ""
            fi
          }
          
          # Lire les variables depuis setup-front/.env si le fichier existe
          if [ -f "setup-front/.env" ]; then
            echo "âœ… Fichier .env trouvÃ©, lecture des variables..."
            
            # Extraire les variables EmailJS
            VITE_EMAILJS_PUBLIC_KEY=$(extract_env_var "VITE_EMAILJS_PUBLIC_KEY" "setup-front/.env")
            VITE_EMAILJS_SERVICE_ID=$(extract_env_var "VITE_EMAILJS_SERVICE_ID" "setup-front/.env")
            VITE_EMAILJS_CONTACT_TEMPLATE_ID=$(extract_env_var "VITE_EMAILJS_CONTACT_TEMPLATE_ID" "setup-front/.env")
            VITE_EMAILJS_NEWSLETTER_TEMPLATE_ID=$(extract_env_var "VITE_EMAILJS_NEWSLETTER_TEMPLATE_ID" "setup-front/.env")
            
            # Afficher les variables (masquer les valeurs sensibles)
            if [ -n "$VITE_EMAILJS_PUBLIC_KEY" ]; then
              echo "VITE_EMAILJS_PUBLIC_KEY=${VITE_EMAILJS_PUBLIC_KEY:0:10}..."
            else
              echo "VITE_EMAILJS_PUBLIC_KEY=(vide)"
            fi
            if [ -n "$VITE_EMAILJS_SERVICE_ID" ]; then
              echo "VITE_EMAILJS_SERVICE_ID=${VITE_EMAILJS_SERVICE_ID:0:10}..."
            else
              echo "VITE_EMAILJS_SERVICE_ID=(vide)"
            fi
            if [ -n "$VITE_EMAILJS_CONTACT_TEMPLATE_ID" ]; then
              echo "VITE_EMAILJS_CONTACT_TEMPLATE_ID=${VITE_EMAILJS_CONTACT_TEMPLATE_ID:0:10}..."
            else
              echo "VITE_EMAILJS_CONTACT_TEMPLATE_ID=(vide)"
            fi
            if [ -n "$VITE_EMAILJS_NEWSLETTER_TEMPLATE_ID" ]; then
              echo "VITE_EMAILJS_NEWSLETTER_TEMPLATE_ID=${VITE_EMAILJS_NEWSLETTER_TEMPLATE_ID:0:10}..."
            else
              echo "VITE_EMAILJS_NEWSLETTER_TEMPLATE_ID=(vide)"
            fi
            
            # Exporter pour les prochaines Ã©tapes
            echo "VITE_EMAILJS_PUBLIC_KEY=${VITE_EMAILJS_PUBLIC_KEY}" >> $GITHUB_ENV
            echo "VITE_EMAILJS_SERVICE_ID=${VITE_EMAILJS_SERVICE_ID}" >> $GITHUB_ENV
            echo "VITE_EMAILJS_CONTACT_TEMPLATE_ID=${VITE_EMAILJS_CONTACT_TEMPLATE_ID}" >> $GITHUB_ENV
            echo "VITE_EMAILJS_NEWSLETTER_TEMPLATE_ID=${VITE_EMAILJS_NEWSLETTER_TEMPLATE_ID}" >> $GITHUB_ENV
          else
            echo "âš ï¸ Fichier setup-front/.env non trouvÃ©, utilisation de valeurs vides"
            echo "VITE_EMAILJS_PUBLIC_KEY=" >> $GITHUB_ENV
            echo "VITE_EMAILJS_SERVICE_ID=" >> $GITHUB_ENV
            echo "VITE_EMAILJS_CONTACT_TEMPLATE_ID=" >> $GITHUB_ENV
            echo "VITE_EMAILJS_NEWSLETTER_TEMPLATE_ID=" >> $GITHUB_ENV
          fi
      
      # Ã‰tape 6: Build Docker Image (le contexte "." existe maintenant)
      - name: ğŸ”¨ Build Docker Image
        env:
          DOCKER_BUILDKIT: 0
        run: |
          # VÃ©rifier que le login fonctionne
          echo "VÃ©rification de l'authentification DockerHub..."
          docker info | grep -i "username" || echo "âš ï¸ Pas de username dans docker info (peut Ãªtre normal)"
          
          # PrÃ©parer les tags
          TAGS="${{ steps.meta.outputs.tags }}"
          if [ -z "$TAGS" ]; then
            # Fallback si metadata-action ne fonctionne pas
            TAGS="${{ env.DOCKER_IMAGE }}:latest ${{ env.DOCKER_IMAGE }}:${{ github.sha }}"
          fi
          
          # Construire les arguments --tag
          TAG_ARGS=""
          for tag in $TAGS; do
            TAG_ARGS="$TAG_ARGS --tag $tag"
          done
          
          # Construire l'image (le contexte "." devrait maintenant exister)
          # Utiliser --pull pour forcer le pull des images de base avec authentification
          docker build \
            --pull \
            --file ${{ env.DOCKERFILE_PATH }} \
            $TAG_ARGS \
            --build-arg VITE_EMAILJS_PUBLIC_KEY="${VITE_EMAILJS_PUBLIC_KEY}" \
            --build-arg VITE_EMAILJS_SERVICE_ID="${VITE_EMAILJS_SERVICE_ID}" \
            --build-arg VITE_EMAILJS_CONTACT_TEMPLATE_ID="${VITE_EMAILJS_CONTACT_TEMPLATE_ID}" \
            --build-arg VITE_EMAILJS_NEWSLETTER_TEMPLATE_ID="${VITE_EMAILJS_NEWSLETTER_TEMPLATE_ID}" \
            --build-arg VITE_APP_NAME="KOBE Corporation" \
            --build-arg VITE_APP_URL="https://kobecorporation.com" \
            ${{ env.DOCKER_CONTEXT }}
          
          # Push l'image si ce n'est pas une PR
          if [ "${{ github.event_name }}" != "pull_request" ]; then
            for tag in $TAGS; do
              echo "Pushing $tag..."
              docker push $tag
            done
          fi
      
      # Ã‰tape 7: Afficher les informations de l'image
      - name: ğŸ“Š Image Info
        if: success()
        run: |
          echo "âœ… Image buildÃ©e avec succÃ¨s!"
          echo "ğŸ“¦ Image: ${{ env.DOCKER_IMAGE }}"
          echo "ğŸ·ï¸  Tags: ${{ steps.meta.outputs.tags }}"
          docker images | grep "${{ env.DOCKER_IMAGE }}"
  
  # ==========================================
  # JOB 3: Test Docker Image (optionnel pour l'instant)
  # ==========================================
  test:
    name: ğŸ§ª Test Docker Image
    runs-on: ubuntu-latest
    needs: build
    if: github.event_name != 'pull_request'  # Skip tests sur PR
    
    steps:
      # Ã‰tape 1: Checkout
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4
      
      # Ã‰tape 2: Nettoyer et recrÃ©er les contextes Docker correctement
      - name: ğŸ§¹ Setup Docker Properly
        run: |
          # Supprimer buildx et contextes corrompus
          rm -rf ~/.docker/buildx 2>/dev/null || true
          rm -rf ~/.docker/contexts 2>/dev/null || true
          
          # RecrÃ©er la structure de contextes correctement
          mkdir -p ~/.docker/contexts/meta
          
          # CrÃ©er le rÃ©pertoire pour le contexte "." (hash de l'erreur)
          CONTEXT_DIR=~/.docker/contexts/meta/cdb4ee2aea69cc6a83331bbe96dc2caa9a299d21329efb0336fc02a82e1839a8
          mkdir -p "$CONTEXT_DIR"
          
          # CrÃ©er le fichier meta.json pour le contexte "."
          cat > "$CONTEXT_DIR/meta.json" <<'EOF'
          {
            "Name": ".",
            "Metadata": {
              "Description": "Default context"
            },
            "Endpoints": {
              "docker": {
                "Host": "unix:///var/run/docker.sock",
                "SkipTLSVerify": false
              }
            }
          }
          EOF
          
          # VÃ©rifier que le fichier a Ã©tÃ© crÃ©Ã©
          if [ -f "$CONTEXT_DIR/meta.json" ]; then
            echo "âœ… Contexte Docker '.' crÃ©Ã© avec succÃ¨s"
          else
            echo "âŒ Erreur: Impossible de crÃ©er le contexte"
            exit 1
          fi
      
      # Ã‰tape 3: Login Ã  DockerHub
      - name: ğŸ” Login to DockerHub
        run: |
          echo "${{ secrets.DOCKERHUB_PASSWORD }}" | docker login -u "${{ secrets.DOCKERHUB_USERNAME }}" --password-stdin
          echo "âœ… Login DockerHub rÃ©ussi"
      
      # Ã‰tape 4: Pull l'image buildÃ©e
      - name: ğŸ³ Pull Docker Image
        run: |
          docker pull ${{ env.DOCKER_IMAGE }}:latest || echo "Image not found, will build locally"
      
      # Ã‰tape 5: Test basique (vÃ©rifier que le conteneur dÃ©marre)
      - name: âœ… Test Container Start
        run: |
          docker run -d --name test-container -p 8080:80 ${{ env.DOCKER_IMAGE }}:latest || docker run -d --name test-container -p 8080:80 ${{ env.DOCKER_IMAGE }}:${{ github.sha }}
          sleep 5
          curl -f http://localhost:8080 || exit 1
          echo "âœ… Container started successfully!"
          docker stop test-container
          docker rm test-container

  # ==========================================
  # JOB 4: Create GitHub Release
  # ==========================================
  release:
    name: ğŸš€ Create GitHub Release
    runs-on: ubuntu-latest
    needs: [tags, build]
    if: |
      github.event_name != 'pull_request' && 
      (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master') &&
      needs.tags.outputs.is_release == 'true'
    
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: ğŸ“‹ Generate Release Notes
        id: release_notes
        run: |
          TAG_NAME="${{ needs.tags.outputs.tag_name }}"
          VERSION="${{ needs.tags.outputs.semantic_version }}"
          CHANGE_TYPE="${{ needs.tags.outputs.tag_type }}"
          
          # RÃ©cupÃ©rer les commits depuis le dernier tag sÃ©mantique
          LAST_TAG=$(git describe --tags --abbrev=0 --match "v[0-9]*" 2>/dev/null || echo "")
          
          if [ -n "$LAST_TAG" ]; then
            echo "ğŸ“ GÃ©nÃ©ration des notes depuis le tag $LAST_TAG"
            COMMITS=$(git log ${LAST_TAG}..HEAD --pretty=format:"- %s (%h)" --no-merges)
          else
            echo "ğŸ“ Premier tag sÃ©mantique, rÃ©cupÃ©ration des 10 derniers commits"
            COMMITS=$(git log -10 --pretty=format:"- %s (%h)" --no-merges)
          fi
          
          # CrÃ©er le body de la release
          RELEASE_BODY="## ğŸ‰ Release $TAG_NAME
          
          **Version:** $VERSION
          **Type:** $CHANGE_TYPE
          
          ### ğŸ“¦ Image Docker
          L'image Docker est disponible sur Docker Hub :
          \`\`\`
          docker pull ${{ env.DOCKER_IMAGE }}:$TAG_NAME
          docker pull ${{ env.DOCKER_IMAGE }}:latest
          \`\`\`
          
          ### ğŸ“ Changements
          $COMMITS
          
          ### ğŸ”— Liens
          - **Docker Hub:** https://hub.docker.com/r/${{ env.DOCKER_IMAGE }}
          - **Commit:** [${{ github.sha }}](https://github.com/${{ github.repository }}/commit/${{ github.sha }})
          
          ---
          *GÃ©nÃ©rÃ© automatiquement par GitHub Actions*"
          
          # Sauvegarder dans un fichier temporaire
          echo "$RELEASE_BODY" > release_notes.md
          echo "âœ… Notes de release gÃ©nÃ©rÃ©es"
          
          # Afficher un aperÃ§u
          echo "ğŸ“„ AperÃ§u des notes de release:"
          head -20 release_notes.md
      
      - name: ğŸš€ Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ needs.tags.outputs.tag_name }}
          name: Release ${{ needs.tags.outputs.tag_name }}
          body_path: release_notes.md
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}